#!/bin/bash
#########################################################
# Please edit "User Configuration" section before using #
#########################################################

#============================================================================
# Terminal Color Codes
#============================================================================
WHITE='\[\033[1;37m\]'
LIGHTGRAY='\[\033[0;37m\]'
GRAY='\[\033[1;30m\]'
BLACK='\[\033[0;30m\]'
RED='\[\033[0;31m\]'
LIGHTRED='\[\033[1;31m\]'
GREEN='\[\033[0;32m\]'
LIGHTGREEN='\[\033[1;32m\]'
BROWN='\[\033[0;33m\]' #Orange
YELLOW='\[\033[1;33m\]'
BLUE='\[\033[0;34m\]'
LIGHTBLUE='\[\033[1;34m\]'
PURPLE='\[\033[0;35m\]'
PINK='\[\033[1;35m\]' #Light Purple
CYAN='\[\033[0;36m\]'
LIGHTCYAN='\[\033[1;36m\]'
DEFAULT='\[\033[0m\]'

#============================================================================
# User Configuration
#============================================================================
# Colors
cLINES=$GRAY #Lines and Arrow
cBRACKETS=$GRAY # Brackets around each data item
cERROR=$RED # Error block when previous command did not return 0
cTIME=$LIGHTGRAY # The current time
cMPX1=$YELLOW # Color for terminal multiplexer threshold 1
cMPX2=$LIGHTRED # Color for terminal multiplexer threshold 2
cBGJ1=$YELLOW # Color for background job threshold 1
cBGJ2=$LIGHTRED # Color for background job threshold 2
cSTJ1=$YELLOW # Color for background job threshold 1
cSTJ2=$LIGHTRED # Color for  background job threshold 2
cSSH=$LIGHTCYAN # Color replacement if session is an SSH session
cUHS=$GRAY # Color of the user and hostname separator
cRWN=$LIGHTRED # Color of root warning
cPWD=$BLUE # Color of current directory
cCMD=$DEFAULT # Color of the command you type
cRR=$LIGHTRED # Color of the star that shows when a system reboot is required
cUSR=$GREEN # Color of user
cHST=$LIGHTGREEN # Color of hostname

#case $(hostname --short) in
#rivendell|mordor|osgiliath)
#  cUSR=$GREEN # Color of user
#  cHST=$LIGHTGREEN # Color of hostname
#  ;;
#erebor|esgaroth)
#  cUSR=$BROWN # Color of user
#  cHST=$YELLOW # Color of hostname
#  ;;
#paranor)
#  cUSR=$BLUE # Color of user
#  cHST=$LIGHTBLUE # Color of hostname
#  ;;
#*)
#  cUSR=$RED # Color of user
#  cHST=$LIGHTRED # Color of hostname
#  ;;
#esac

# Enable block
eNL=1   # Have a newline between previous command output and new prompt
eSL=1   # Generate a second line to function as the actual prompt
eRR=1   # Show a warning symbol if a system restart is required
eERR=1  # Previous command return status tracker
eMPX=1  # Terminal multiplexer tracker enabled
eSSH=1  # Track if session is SSH
eBGJ=1  # Track background jobs
eSTJ=1  # Track stopped jobs
ePWD=1  # Show current directory
eWWR=0  # Show a warming symbol when user is root
eUWWR=1 # Change the colour of the username when root
eSUWR=1 # Show user when root
eSHWR=1 # Show hostname when root
eUSER=1 # Show user
eHOST=1 # Show hostname
eTIME=0 # Show the current time

# Block settings
MPXT1="0" # Terminal multiplexer min threshold
MPXT2="2" # Terminal multiplexer max threshold
BGJT1="0" # Background job min threshold
BGJT2="2" # Background job max threshold
STJT1="0" # Stopped job min threshold
STJT2="2" # Stopped job max threshold
BGJI="&" # Background jobs indicator
DSI="\342\230\220" # Detached screen/tmux sessions indicator
SJI="\342\234\227" # Stopped jobs indicator
RBI="\342\230\205" # Reboot indicator
UHS="@" # User and hostname seperator
RWN="!" # Root warning indicator

function promptcmd()
{
  PREVRET=$?

  #========================================================================
  # If the user is in an ssh session, change the colour of certain elements
  #========================================================================
  if [ $eSSH -eq 1 ] ; then
    if [[ $SSH_CLIENT ]] || [[ $SSH2_CLIENT ]]; then
#      cBRACKETS=${cSSH}
#      cLINES=${cSSH}
      cUHS=${cSSH}
    fi
  fi

  #========================================================================
  # Insert a new line to clear space from previous command
  #========================================================================
  if [ $eNL -eq 1 ] ; then
    PS1="\n"
  fi

  #========================================================================
  # Beginning of first line (arrow wrap around and color setup)
  #========================================================================
  if [ $eSL -eq 1 ] ; then
    PS1="${PS1}${cLINES}\342\224\214\342\224\200"
  else
    PS1="${PS1}${cLINES}\342\224\200"
  fi

  #========================================================================
  # Current time
  #========================================================================
  if [ $eTIME -eq 1 ] ; then
    PS1="${PS1}${cBRACKETS}[${cTIME}\t${cBRACKETS}]${cLINES}\342\224\200"
  fi

  #========================================================================
  # User @ host
  #========================================================================
  PS1="${PS1}${cBRACKETS}["
  if [ $eWWR -eq 1 ] && [ $EUID -eq 0 ] ; then
    PS1="${PS1}${cRWN}${RWN}"
  fi
  if [ $EUID -eq 0 ] ; then
    if [ $eSUWR -eq 1 ] ; then
      if [ $eUWWR -eq 1 ] ; then
        cUSR=${cRWN}
      fi
      PS1="${PS1}${cUSR}\u"
    fi
    if [ $eSUWR -eq 1 ] && [ $eSHWR -eq 1 ] ; then
      PS1="${PS1}${cUHS}${UHS}"
    fi
    if [ $eSHWR -eq 1 ] ; then
      PS1="${PS1}${cHST}\h"
    fi
  elif [ $eUSER -eq 1 ] ; then
    PS1="${PS1}${cUSR}\u"
    if [ $eUSER -eq 1 ] && [ $eHOST -eq 1 ] ; then
      PS1="${PS1}${cUHS}${UHS}"
    fi
    if [ $eHOST -eq 1 ] ; then
      PS1="${PS1}${cHST}\h"
    fi
  fi
  PS1="${PS1}${cBRACKETS}]${cLINES}\342\224\200"

  #========================================================================
  # Previous command error
  #========================================================================
  if [ $eERR -eq 1 ] && [ $PREVRET -ne 0 ] ; then
#    PS1="${PS1}${cBRACKETS}[${cERROR}:(${cBRACKETS}]${cLINES}\342\224\200"
    PS1="${PS1}${cBRACKETS}[${cERROR}${PREVRET}${cBRACKETS}]${cLINES}\342\224\200"
  fi

  #========================================================================
  # Detached screen sessions
  #========================================================================
  if [ $eMPX -eq 1 ] ; then
    hTMUX=0
    hSCREEN=0
    MPXC=0
    hash tmux 2>/dev/null || hTMUX=1
    hash screen 2>/dev/null || hSCREEN=1
    if [ $hTMUX -eq 0 ] && [ $hSCREEN -eq 0 ] ; then
      MPXC=$(echo "$(screen -ls | /bin/grep -c -i detach) + $(tmux ls 2>/dev/null | /bin/grep -c -i -v attach)" | bc)
    elif [ $hTMUX -eq 0 ] && [ $hSCREEN -eq 1 ] ; then
      MPXC=$(tmux ls 2>/dev/null | /bin/grep -c -i -v attach)
    elif [ $hTMUX -eq 1 ] && [ $hSCREEN -eq 0 ] ; then
      MPXC=$(screen -ls | /bin/grep -c -i detach)
    fi

    if [[ $MPXC -gt $MPXT2 ]] ; then
      PS1="${PS1}${cBRACKETS}[${cMPX2}${DSI}:${MPXC}${cBRACKETS}]${cLINES}\342\224\200"
    elif [[ $MPXC -gt $MPXT1 ]] ; then
      PS1="${PS1}${cBRACKETS}[${cMPX1}${DSI}:${MPXC}${cBRACKETS}]${cLINES}\342\224\200"
    fi
  fi

  #========================================================================
  # Backgrounded running jobs
  #========================================================================
  if [ $eBGJ -eq 1 ] ; then
    BGJC=$(jobs -r | wc -l )
    if [ ${BGJC} -gt ${BGJT2} ] ; then
      PS1="${PS1}${cBRACKETS}[${cBGJ2}${BGJI}:${BGJC}${cBRACKETS}]${cLINES}\342\224\200"
    elif [ ${BGJC} -gt ${BGJT1} ] ; then
      PS1="${PS1}${cBRACKETS}[${cBGJ1}${BGJI}:${BGJC}${cBRACKETS}]${cLINES}\342\224\200"
    fi
  fi

  #========================================================================
  # Stopped jobs
  #========================================================================
  if [ $eSTJ -eq 1 ] ; then
    STJC=$(jobs -s | wc -l )
    if [ ${STJC} -gt ${STJT2} ] ; then
      PS1="${PS1}${cBRACKETS}[${cSTJ2}${SJI}:${STJC}${cBRACKETS}]${cLINES}\342\224\200"
    elif [ ${STJC} -gt ${STJT1} ] ; then
      PS1="${PS1}${cBRACKETS}[${cSTJ1}${SJI}:${STJC}${cBRACKETS}]${cLINES}\342\224\200"
    fi
  fi

  #========================================================================
  # Reboot required
  #========================================================================
  if [ $eRR -eq 1 ] ; then
    if [ -f /run/reboot-required ] ; then
      PS1="${PS1}${cBRACKETS}[${cRR}${RBI}${cBRACKETS}]${cLINES}\342\224\200"
    fi
  fi

  #========================================================================
  # Current directory
  #========================================================================
  if [ $ePWD -eq 1 ] ; then
    PS1="${PS1}${cBRACKETS}[${cPWD}\w${cBRACKETS}]"
  fi

  #========================================================================
  # Second line
  #========================================================================
  if [ $eSL -eq 1 ] ; then
    PS1="${PS1}\n${cLINES}\342\224\224\342\224\200\342\224\200\342\224\200> ${cCMD}"
  else
    PS1="${PS1}${cLINES}\342\224\200> ${cCMD}"
  fi
}

function load_prompt () {
  # Get PIDs
  local parent_process=$(cut -d '' -f 1 /proc/$PPID/cmdline)
  local my_process=$(cut -d '' -f 1 /proc/$$/cmdline)

  if [[ $parent_process == script* ]]; then
    PROMPT_COMMAND=""
    PS1="\t - \# - \u@\H { \w }\$ "
  elif [[ $parent_process == emacs* || $parent_process == xemacs* ]]; then
    PROMPT_COMMAND=""
    PS1="\u@\h { \w }\$ "
  else
    export DAY=$(date +%A)
    PROMPT_COMMAND=promptcmd
  fi
  export PS1 PROMPT_COMMAND
}

load_prompt
